---
title: Layout System
description: How to build flexible and responsive layouts with ReactiveUI.
---

## The Power of Flexbox

ReactiveUI integrates **Meta's Yoga layout engine**, a high-performance implementation of the popular **Flexbox** model from web development. This means you can build complex, responsive, and resolution-independent UIs directly in C# with a familiar and powerful API.

Forget manual `RectTransform` calculations. With ReactiveUI's layout system, you describe how components should behave, and Yoga handles the rest.

Key concepts of the layout system:
- **Flex Container**: A component that contains other components and defines how they are laid out. You create one with the `AsFlexGroup()` extension method.
- **Flex Item**: A component within a flex container. It can have its own layout properties. You create one with `AsFlexItem()`.
- **Main Axis & Cross Axis**: The primary axes along which items are laid out. The `FlexDirection` property on a container determines these axes.

---

## Creating a Layout Root: `AsFlexGroup`

Any component that needs to arrange its children using flexbox must be configured as a flex container. This is done using the `.AsFlexGroup()` extension method.

```csharp
new Container()
    .AsFlexGroup(
        direction: FlexDirection.Row,
        justifyContent: Justify.Center,
        alignItems: Align.Center
    )
```

The `AsFlexGroup` method has several parameters to control the layout of its children:

| Parameter        | Type                                | Description                                                                                               |
| ---------------- | ----------------------------------- | --------------------------------------------------------------------------------------------------------- |
| `direction`      | `FlexDirection`                     | Defines the main axis. Can be `Row` (default), `RowReverse`, `Column`, or `ColumnReverse`.                |
| `justifyContent` | `Justify`                           | How children are distributed along the main axis. e.g., `FlexStart`, `Center`, `FlexEnd`, `SpaceBetween`.    |
| `alignItems`     | `Align`                             | How children are aligned along the cross axis. e.g., `FlexStart`, `Center`, `FlexEnd`, `Stretch`.           |
| `alignContent`   | `Align`                             | How lines are aligned when there are multiple lines (see `wrap`). Only applies if `wrap` is not `NoWrap`. |
| `wrap`           | `Wrap`                              | Whether items should wrap to a new line if they don't fit. `NoWrap` (default), `Wrap`, `WrapReverse`.      |
| `padding`        | `YogaFrame`                         | The space between the container's edge and its children. e.g., `new YogaFrame(10)` for all sides.         |
| `gap`            | `YogaVector`                        | The gap between children. e.g., `new YogaVector(5, 5)` for row and column gaps.                           |

> **Note:** You can initialize `YogaFrame` and `YogaVector` in multiple ways, such as `new YogaFrame(10)` for all sides, or `new() { Top = 5, Bottom = 5 }` to set specific sides.

---

## Arranging Components: `AsFlexItem`

Once a component is inside a flex container, you can control its individual layout properties using the `.AsFlexItem()` extension method.

```csharp
new Label("Hello")
    .AsFlexItem(
        flexGrow: 1,
        alignSelf: Align.Stretch
    )
```

`AsFlexItem` provides fine-grained control over a component's sizing, spacing, and alignment within its container.

| Parameter     | Type          | Description                                                                                                   |
| ------------- | ------------- | ------------------------------------------------------------------------------------------------------------- |
| `flexGrow`    | `float`       | How much the item should grow to fill available space. A value of `1` means it will take up all available space. |
| `flexShrink`  | `float`       | How much the item should shrink if there isn't enough space.                                                  |
| `flexBasis`   | `YogaValue`   | The default size of an item before growing or shrinking. Can be a percentage or a point value.                |
| `size`        | `YogaVector`  | The fixed size of the item.                                                                                   |
| `minSize`     | `YogaVector`  | The minimum size of the item.                                                                                 |
| `maxSize`     | `YogaVector`  | The maximum size of the item.                                                                                 |
| `margin`      | `YogaFrame`   | The space around the item, outside of its border.                                                             |
| `alignSelf`   | `Align`       | Overrides the container's `alignItems` for this specific item.                                                |
| `position`    | `YogaFrame`   | Allows you to position an item absolutely within its container. Requires `positionType` to be `Absolute`.     |
| `positionType`| `PositionType`| The positioning mode. `Relative` (default) or `Absolute`.                                                     |

---

## Example: A Simple Menu

Let's combine these concepts to create a simple vertical menu with a header and three buttons that fill the available space.

```csharp
class SimpleMenu : ReactiveComponent {
    protected override GameObject Construct() {
        return new Container()
            .AsFlexGroup(
                direction: FlexDirection.Column,
                padding: new YogaFrame(10),
                gap: new YogaVector(5, 0)
            )
            .WithChildren(
                new Label("My Menu")
                    .AsFlexItem(
                        alignSelf: Align.Center,
                        margin: new YogaFrame { Bottom = 10 }
                    ),
                new Button("Button 1")
                    .AsFlexItem(flexGrow: 1),
                new Button("Button 2")
                    .AsFlexItem(flexGrow: 1),
                new Button("Button 3")
                    .AsFlexItem(flexGrow: 1)
            )
            .Use();
    }
}
```

In this example:
1.  The root `Container` is our flex container, arranging children in a `Column`.
2.  It has `10` units of padding on all sides and a `5` unit gap between its children.
3.  The `Label` is centered and has some bottom margin.
4.  The `Button`s have `flexGrow: 1`, so they expand equally to fill the remaining vertical space. 

---

## Nested Layouts

A powerful feature of the layout system is that any flex item can also be a flex container for its own children. This allows you to build complex, hierarchical layouts by nesting `AsFlexGroup` configurations.

You achieve this by chaining the extension methods. A component becomes both an item in a parent layout and a container for its own children.

```csharp
// This component is an item in its parent's layout
// AND a container for its own children.
new Layout()
    .AsFlexGroup(...) // Defines how its children are arranged
    .AsFlexItem(...)  // Defines how it behaves in its parent
```

---

## Example: Two-Column Card

Let's build a card with an image on the left and a title/subtitle on the right. This requires nesting a vertical layout (`Column`) inside a horizontal one (`Row`).

```csharp
class InfoCard : ReactiveComponent {
    protected override GameObject Construct() {
        // The root component is a Row container
        return new Container()
            .AsFlexGroup(
                direction: FlexDirection.Row,
                alignItems: Align.Center,
                padding: new(10),
                gap: new(10, 0)
            )
            .WithChildren(
                // 1. The Image
                new WebImage("path/to/image.png")
                    .AsFlexItem(
                        size: new() { width = 50, height = 50 }
                    ),

                // 2. The Text section, which is both an item and a group
                new Layout()
                    .AsFlexGroup( // It's a group for the labels
                        direction: FlexDirection.Column,
                        gap: new(0, 5)
                    )
                    .AsFlexItem( // It's an item in the main row
                        flexGrow: 1
                    )
                    .WithChildren(
                        new Label("Main Title")
                            .AsFlexItem(),
                        new Label("This is a longer subtitle for the card.")
                            .AsFlexItem()
                    )
            )
            .Use(); // Don't forget .Use() to build the GameObject!
    }
}
```

In this example:
1.  The root `Container` is a **Row** that aligns its direct children (`WebImage`, `Layout`).
2.  The `WebImage` is a simple flex item with a fixed size.
3.  The `Layout` component is special:
    *   `.AsFlexItem(flexGrow: 1)` makes it a flex item that expands to fill the available width in the main row.
    *   `.AsFlexGroup(...)` makes it a **Column** container that arranges its own children (the two `Label`s) vertically.

This nesting pattern is key to building almost any UI you can imagine.

> **Final Step: `.Use()`**
> As you can see in the examples, the component declaration chain must end with a call to `.Use()`. This is the final step that takes your declarative definition and constructs the actual `GameObject` in the scene. Without it, nothing will be rendered. 