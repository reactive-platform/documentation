---
title: Layout
description: How the layout system works.
---

## The Power of Flexbox

ReactiveUI uses **Yoga**, a high-performance implementation of the popular **Flexbox** model from web development.
This means you can build complex, responsive, and resolution-independent UIs with a familiar and powerful API.

Key concepts of the layout system:
- **Flex Container**: A component that contains other components and defines how they are laid out. You create one with the `AsFlexGroup()` extension method.
- **Flex Item**: A component within a flex container. It can have its own layout properties. You create one with `AsFlexItem()`.
- **Main Axis & Cross Axis**: The primary axes along which items are laid out. The `FlexDirection` property on a container determines these axes.

---

## How reactive works with Yoga

In advance, this section is not supposed to tell you how to use the Yoga's flexbox model, that info is already available on the Yoga's website (https://www.yogalayout.dev/docs/about-yoga).
Instead, we will talk about how Yoga is implemented in reactive and what you should know to use it flawlessly.

So, let's start with the basics: in Yoga every node is a controller and an item at the same time, this means that you add properties and don't care about the rest.

But Reactive's layout model is designed a little bit different: an item without an explicitly defined controller is NOT in the layout flow unless that item is not a controller itself.
This means that `.AsFlexItem` without `.AsFlexGroup` on a containing object, does nothing.

```csharp
new Background {
    Children = {
        new Label {
            Text = "Hello world"
        }.AsFlexItem()
    }
};
```

Let's look at this example. That's how it will look in the game:

![Broken layout](/assets/layout-broken-1.png)

But why so? What just happened? As `Background` does not have a defined controller, it just has grown up to 100x100, which is Unity's rect default size.
To fix this, we should define a controller by calling `AsFlexGroup` on the `Background`.

```csharp
new Background {
    Children = {
        new Label {
            Text = "Hello world"
        }.AsFlexItem()
    }
}.AsFlexGroup();
```

Let's take a look at the fixed version:

![Fixed layout](/assets/layout-fixed-1.png)

By a wave of the magic wand, we've got it to take all available space in the view. Furthermore, the `Label` is at the start now.
So, we've just added a flex controller that connected the background with the label. Now we can change properties to see what happens:

```csharp
new Background {
    Children = {
        new Label {
            Text = "Hello world"
        }.AsFlexItem()
    }
}.AsFlexGroup(justifyContent: Justify.Center);
```

![Fixed layout](/assets/layout-fixed-2.png)

Changing `JustifyContent` led to label being placed at the center. Pretty easy, ain't it?
Starting from this point, everything works exactly like in Yoga.

## Layout recalculation

So, you've just learned about the layout system in general. But sometimes you need to know how exactly everything works to implement and optimize things.
The recalculation policy is pretty straightforward. There are three ways of layout recalculation:
- Immediate (happens immediately)
- Deferred (happens in LateUpdate)
- Deferred with transferred intention (basically the same as the previous one, but recalculation intention is transferred to the parent)

In 99% of cases, reactive uses either the second or the third one. But what is that 1 percent?
Well, sometimes it is necessary to maintain manual layout or have it calculated even that the object is disabled.
And here comes immediate recalculation: you subscribe to the recalculation of the main flow and cause recalculation in the second flow manually.
You would ask: why not use Deferred recalculation there, or let it recalculate automatically? That's a good question.
The answer is that it would cause a 1 frame *gap* that is usually noticeable if you are attentive.

So, let's get back to the deferred recalculation. In general, everything is as simple as you imagine it:
when a property is updated, it tells the host that its dirty now, so it has to recalculate.
Why not do it immediately? That's another good one. What we do is bet on the case when multiple properties are updated
and this way of recalculation allows decreasing recalculations count to just 1.

About the *Deferred with transferred intention*. It's the same as the previous one, but happens when the object is
not capable of updating the layout itself (e.g., when it's getting disabled), so it transfers the intention to the parent.
In case there is no parent, it's assumed that the hierarchy is not visible, so no need to recalculate until it gets enabled back.

The whole flow can be explained better with a diagram:

<Mermaid chart={
  `flowchart LR
    A(["Component updated"]) --> B{"Disabled? <br>"}
    B -- Yes <br> --> C["Has parent?"]
    C -- Yes <br> --> n2["Move to parent <br>"]
    C -- No <br> --> n4["Defer recalcultion"]
    B -- No <br> --> n4
    n2 --> n4
    C@{ shape: diam}
    n4@{ shape: subproc}`
}/>
